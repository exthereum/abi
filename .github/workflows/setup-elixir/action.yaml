name: Set up Elixir with cached build
description: "pulls in the elixir dependencies and builds a cache for the compiled build"
inputs:
  mix_env:
    description: "MIX_ENV to compile"
    required: true
    default: "test"

runs:
  using: "composite"
  steps:
    # Step: Setup Elixir + Erlang image as the base.
    - name: Set up Elixir
      uses: erlef/setup-beam@v1
      with:
        otp-version: "26.1.2"
        elixir-version: "1.15"

    # Step: Define how to cache deps. Restores existing cache if present.
    - name: Cache deps
      id: cache-deps
      uses: actions/cache@v3
      env:
        cache-name: cache-elixir-deps
      with:
        path: deps
        key: ${{ runner.os }}-mix-${{ inputs.mix_env }}-${{ env.cache-name }}-${{ hashFiles('**/mix.lock') }}
        restore-keys: |
          ${{ runner.os }}-mix-${{ inputs.mix_env }}-${{ env.cache-name }}-

    # Step: Define how to cache the `_build` directory. After the first run,
    # this speeds up tests runs a lot. This includes not re-compiling our
    # project's downloaded deps every run.
    - name: Cache compiled build
      id: cache-build
      uses: actions/cache@v3
      env:
        cache-name: cache-compiled-build
      with:
        path: _build
        key: ${{ runner.os }}-mix-${{ inputs.mix_env }}-${{ env.cache-name }}-${{ hashFiles('**/mix.lock') }}
        restore-keys: |
          ${{ runner.os }}-mix-${{ inputs.mix_env }}-${{ env.cache-name }}-
          ${{ runner.os }}-mix-${{ inputs.mix_env }}-

    # Step: Download project dependencies. If unchanged, uses
    # the cached version.
    - name: Install dependencies
      shell: bash
      run: mix deps.get

    # Step: Compile the project for test and cache the build
    - name: Build for cache
      shell: bash
      run: mix compile
      env:
        MIX_ENV: ${{ inputs.mix_env }}
